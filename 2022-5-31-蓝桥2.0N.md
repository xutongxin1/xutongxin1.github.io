

# 该文章将记录蓝桥杯的模块使用方案 等

## 省赛

### 按键

别老惦记着你那外部中断啦，不行的，老老实实按键扫描就好

记得在cubemx里初始化，但是不需要上下拉（因为官方也没有做）

消抖是必须要做的，但是只需要10ms就好（因为官方这么写的）

按键的一种写法:

```c
#define B1 HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0)
#define B2 HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_1)
#define B3 HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_2)
#define B4 HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0)

u8 keyScan()
{
    if(B1==0)
    {
        HAL_Delay(10);
        if(B1==0)
            return 1;
    }
    if(B2==0)
    {
        HAL_Delay(10);
        if(B2==0)
            return 2;
    }
    if(B3==0)
    {
        HAL_Delay(10);
        if(B3==0)
            return 3;
    }
    if(B4==0)
    {
        HAL_Delay(10);
        if(B4==0)
            return 4;
    }
    return 0;
}		

u8 nowKey=0,oldKey=0;
while(1)	
{
		nowKey=keyScan();
		if(oldKey!=nowKey)
		{
			oldKey=nowKey;
			switch(nowKey)
			{
				case 0:
					break;
				case 1:
					break;
				case 2:
					break;
				case 3:
					break;
				case 4:
					break;
			}
		}
}
```

消抖，分离按键，防重复触发一体化





### UART

UART使用UART1

空闲中断需要如下配置

![image-20230406211643189](http://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/202304062116406.png)

![image-20230406211654678](http://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/202304062116795.png)

```c
int recLen=100;
char rec[100]="";
int main(void)
{
	__HAL_UART_ENABLE_IT(&huart1,UART_IT_IDLE);
	HAL_UART_Receive_DMA(&huart1,(uint8_t*)rec,recLen);
}
```

```c
void USART1_IRQHandler(void)
{
  /* USER CODE BEGIN USART1_IRQn 0 */
	if(__HAL_UART_GET_IT_SOURCE(&huart1,UART_IT_IDLE)!=RESET){
	__HAL_UART_CLEAR_IDLEFLAG(&huart1);
	HAL_UART_DMAStop(&huart1);
	int recCNT=recLen-__HAL_DMA_GET_COUNTER(huart1.hdmarx);
    //int recCNT=recLen-__HAL_DMA_GET_COUNTER(&hdma_usart1_rx);//等价于上面一句，下面这个变量好找一点
	char tmp[100];
	strncpy(tmp,rec,recCNT);
	HAL_UART_Transmit(&huart1,(uint8_t*)tmp,strlen(tmp),255);//测试发回去
	memset(rec,0,recLen);
	HAL_UART_Receive_DMA(&huart1,(uint8_t*)rec,recLen);
	}
  /* USER CODE END USART1_IRQn 0 */
  HAL_UART_IRQHandler(&huart1);
  /* USER CODE BEGIN USART1_IRQn 1 */

  /* USER CODE END USART1_IRQn 1 */
}
```



### LCD

io：请使用LCD例程模板

为保证在LCD与灯状态的共存，需要做出如下修改

lcd.c

```ceylon
LCD_WriteReg函数
LCD_WriteRAM_Prepare函数
LCD_WriteRAM函数
一共三个函数每个函数前后两行供六行

u16 tmp=GPIOC->ODR;//不能是u8
//函数原本内容
GPIOC->ODR=tmp;
```

LCD每一行最大上限是19个字符，超过上限编译时不会报错，但是会重启炸Fault（推测为内存越界）

写入单字符

```c
sprintf(tmp,"      :%02d:%02d   ",min,sec);//给要写入的带颜色字符留空
LCD_DisplayStringLine(Line3,(uint8_t*)tmp);
LCD_SetTextColor(Red);
LCD_DisplayChar(Line3,319-16*4,hour/10+'0');//对写入单一字符
LCD_DisplayChar(Line3,319-16*5,hour%10+'0');
LCD_SetTextColor(White);
```

第二个参数计算方法是：319-16*字符索引（从0开始索引）

第三个参数需要填写ASCII码，可以使用'0'表示字符0

**记得行数的宏是有Line0的**

```
LCD_DisplayChar(Line0,319-16*5,hour%10+'0');
```

**注意：若连续使用上述代码，会导致一直画面不稳定，应按需刷新**



#### 翻转显示

https://blog.csdn.net/qq_44920338/article/details/125573284

原代码（注释是它的）：

```
LCD_WriteReg(R1  , 0x0000); // set SS and SM bit		  //0x0100
LCD_WriteReg(R96 , 0x2700); // Gate Scan Line		  0xA700
```

修改后：

```
LCD_WriteReg(R1  , 0x0100); // set SS and SM bit	(从下往上)
LCD_WriteReg(R96 , 0xA700); // Gate Scan Line       (从右往左)
```

实现翻转两个都要，否则只是镜像

~~诶：原来它注释提醒了我？？~~

### 板载EEPROM

型号：M24C02-WMN6TP

I2C软件模拟

io：PB6 PB7，GPIO OUTPUT不需要做额外配置。为了delay准确，配置TIM7用于延时控制

![image-20220515154857820](https://raw.githubusercontents.com/xutongxin1/PictureBed/master/img0/image-20220515154857820.png)

![image-20240225184349491](http://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/202402252015409.png)

不用打开中断



移植i2c.h后

默写如下函数到main.c

```c
uint8_t IICRead(uint8_t address)
{
	unsigned char val;
	
	I2CStart(); 
	I2CSendByte(0xa0);
	I2CWaitAck(); 
	
	I2CSendByte(address);
	I2CWaitAck(); 
	
	I2CStart();
	I2CSendByte(0xa1); 
	I2CWaitAck();
	val = I2CReceiveByte(); 
	I2CWaitAck();
	I2CStop();
	
	return(val);
}

//
void IICWrite(unsigned char address,unsigned char info)
{
	I2CStart(); 
	I2CSendByte(0xa0); 
	I2CWaitAck(); 
	
	I2CSendByte(address);	
	I2CWaitAck(); 
	I2CSendByte(info); 
	I2CWaitAck(); 
	I2CStop();
    
}
```

启动->写入元器件写地址->写入写入地址->写入数据->结束

启动->写入元器件写地址->写入读取地址->启动->写入元器件读地址->读取->结束

i2c.c内的delay1修改

```c
/**
  * @brief I2C的短暂延时
  * @param None
  * @retval None
  */
extern TIM_HandleTypeDef htim7;
static void delay1(uint32_t nus)
{

    uint16_t  differ = 0xffff-nus-500;
    //设置定时器2的技术初始值
  __HAL_TIM_SetCounter(&htim7,differ);
  //开启定时器
  HAL_TIM_Base_Start(&htim7);

  while( differ<0xffff-500)
    {
        differ = __HAL_TIM_GetCounter(&htim7);
    };
 //关闭定时器
  HAL_TIM_Base_Stop(&htim7);
}

```



**自己处理一下写入时的Delay**，如果在IICWrite函数内加Delay，然后一不小心在中断里一个调用！卡死了

连续调用IICWrite会导致卡死

### 板载RES（电位器）

![image-20230606165417744](http://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/202306061654904.png)

必须要修改i2c的delay函数

```c
/**
  * @brief I2C的短暂延时
  * @param None
  * @retval None
  */
extern TIM_HandleTypeDef htim7;
static void delay1(uint32_t nus)
{

    uint16_t  differ = 0xffff-nus-500;
    //设置定时器2的技术初始值
  __HAL_TIM_SetCounter(&htim7,differ);
  //开启定时器
  HAL_TIM_Base_Start(&htim7);

  while( differ<0xffff-500)
    {
        differ = __HAL_TIM_GetCounter(&htim7);
    };
 //关闭定时器
  HAL_TIM_Base_Stop(&htim7);
}

```

电位器的步长：0.787402千欧，0-127步

这玩意误差挺大，所以即便实测不准也是正常（实测方法为J15和J16接到欧姆表）

```c
void write_resistor(uint8_t value)
{   
	I2CStart();
	I2CSendByte(0x5E);  
	I2CWaitAck();
	
	I2CSendByte(value);  
	I2CWaitAck();
	I2CStop();
}

uint8_t read_resistor(void)
{   
	uint8_t value; 
	I2CStart();
	I2CSendByte(0x5F);  
	I2CWaitAck();
	
	value = I2CReceiveByte();
	I2CSendNotAck();
	I2CStop();

	return value;
}

		sprintf(buf, "   RES VAL:%.1fK  ", (0.78740*read_resistor()));
		LCD_DisplayStringLine(Line8, (uint8_t *)(buf));
```



### 板载ADC

ADC硬件

io：打开IN15即可，不需要额外配置

![image-20220515161500702](https://raw.githubusercontents.com/xutongxin1/PictureBed/master/img0/image-20220515161500702.png)

main.c

```c
HAL_ADCEx_Calibration_Start(&hadc2,ADC_SINGLE_ENDED);//校准

uint16_t getADC(void)
{
	uint16_t adc = 0;
	
	HAL_ADC_Start(&hadc2);
	adc = HAL_ADC_GetValue(&hadc2);
	
	return adc;
}


sprintf(tmp,"VR37:%.02fV",(float)getADC()/4096*3.3);
```

第二个旋钮用的是ADC1，根本不冲突

```c
double Get_ADC1()
{
    HAL_ADC_Start(&hadc1);
    int tmp=HAL_ADC_GetValue(&hadc1);
    return (double)(tmp)/4096*3.3;
}
double Get_ADC2()
{
    HAL_ADC_Start(&hadc2);
    int tmp=HAL_ADC_GetValue(&hadc2);
    return (double)(tmp)/4096*3.3;
}
```





### 板载LED灯

锁存器，PD2高电平同步，低电平锁存

**警告，例程默认不初始化PD2，记得开**

使用：

main.c

```c
HAL_GPIO_WritePin(GPIOC,GPIO_PIN_All,GPIO_PIN_SET);
HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_SET);
HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_RESET);
//全关灯
```



### RTC

![image-20221128195131167](https://raw.githubusercontents.com/xutongxin1/PictureBed/master/img0/image-20221128195131167.png)

在读取RTC时，读完Time必须要读Date

```c
RTC_DateTypeDef DateTmp;
RTC_TimeTypeDef TimeTmp;
while(1)
{
HAL_RTC_GetTime(&hrtc,&TimeTmp,RTC_FORMAT_BIN);
HAL_RTC_GetDate(&hrtc,&DateTmp,RTC_FORMAT_BIN);
}
```

RTC的报警定时器的使用

![image-20230330170926864](http://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/202303301709079.png)

![image-20230330171052384](http://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/202303301710478.png)

![image-20230330170938750](http://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/202303301709854.png)

其中Alarm Mask Date Week day 指报警忽略日期，必须要开，否则报警要匹配年月日，永远不能报警

若这样配置，默认就会打开一次报警中断

使用回调，或放IQR（虽然我没试过）

```c
void  HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)
{
    char tmp[20]="";
    sprintf(tmp,"%.02f+%.1f+%02d%02d%02d",Get_ADC(),k,Alarm.AlarmTime.Hours,Alarm.AlarmTime.Minutes,Alarm.AlarmTime.Seconds);
    HAL_UART_Transmit(&huart1,(uint8_t*)tmp,strlen(tmp),255);
}
```

需要再次配置报警时要注意！从MX_RTC_Init抄出来配置更好

```c
   RTC_AlarmTypeDef Alarm;
   Alarm.Alarm=RTC_ALARM_A;
   Alarm.AlarmTime.Hours=0;//报警时间
   Alarm.AlarmTime.Minutes=0;
   Alarm.AlarmTime.Seconds=0;
   Alarm.AlarmTime.SubSeconds = 0x0;
   Alarm.AlarmMask = RTC_ALARMMASK_DATEWEEKDAY;//这个是关键，要求忽略年月日!!!
   Alarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_ALL;
   Alarm.AlarmDateWeekDaySel = RTC_ALARMDATEWEEKDAYSEL_DATE;
   Alarm.AlarmDateWeekDay = 0x1;
   Alarm.Alarm = RTC_ALARM_A;//指定哪个报警器
```

最后启动中断

```c
HAL_RTC_SetAlarm_IT(&hrtc,&Alarm,RTC_FORMAT_BIN);//启动中断
```



## 国赛扩展板

国赛板子记得看跳线帽

### 数码管

跳线帽：SCK，RCK，RES

io：不需要配置，在SEG_Init会做

复制文件：seg.c

初始化函数：main.c

```c
SEG_Init();
```

使用：

```c
SEG_DisplayValue(1,1,1);//1,1,1
SEG_DisplayValue(10,10,10);//A,A,A
SEG_DisplayValue(16,16,16);//全灭，达到灭灯的效果！！！
```



### BUTTON(ADC)

跳线帽：AKEY

io：需要配置ADC2，IN13 Single-ended

复制文件：button.c，其中getADC()函数需要自己写

使用：

```c
u8 key_val = Scan_Btn();
```





### 温度传感器（DS18B20）

跳线帽：TDQ

io：不需要配置，在ds18b20_init_x会做

复制文件：ds18b20.c

使用：（视情况可能需要改写其中的u8 u16 u32等类型）

如果需要上外部晶振，需要自己重写delay

开TIM7，1us分频，无需中断

![image-20230609145313992](http://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/202306091453283.png)

```c
static void delay_us(uint32_t nus)
{

    uint16_t  differ = 0xffff-nus-500;
    //设置定时器2的技术初始值
  __HAL_TIM_SetCounter(&htim7,differ);
  //开启定时器
  HAL_TIM_Base_Start(&htim7);

  while( differ<0xffff-500)
    {
        differ = __HAL_TIM_GetCounter(&htim7);
    };
 //关闭定时器
  HAL_TIM_Base_Stop(&htim7);
}

```

理论上需要自己写读取函数

```c
uint16_t ds18b20_read(void)
{
    uint8_t val[2];
    uint8_t i = 0;

    uint16_t x = 0;

    ow_reset();
    ow_byte_wr(OW_SKIP_ROM);
    ow_byte_wr(DS18B20_CONVERT);
    delay_us(750000);

    ow_reset();
    ow_byte_wr( OW_SKIP_ROM );
    ow_byte_wr ( DS18B20_READ );

    for ( i = 0 ; i < 2; i++)
    {
        val[i] = ow_byte_rd();
    }

    x = val[1];
    x <<= 8;
    x |= val[0];

    return x;
}
```

初始化方法

```c
ds18b20_init_x();
read = (ds18b20_read() & 0x07FF);
tem = read / 16.;
```



### 温湿度传感器（DHT11）

跳线帽：HDQ

io：不需要配置，在DHT11_Init会做

复制文件：dht11.c

使用：（视情况可能需要改写其中的u8 u16 u32等类型）

如果需要上外部晶振，需要自己重写delay

开TIM7，1us分频，无需中断

![image-20230609145313992](http://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/202306091453283.png)

```c
static void delay_us(uint32_t nus)
{

    uint16_t  differ = 0xffff-nus-500;
    //设置定时器2的技术初始值
  __HAL_TIM_SetCounter(&htim7,differ);
  //开启定时器
  HAL_TIM_Base_Start(&htim7);

  while( differ<0xffff-500)
    {
        differ = __HAL_TIM_GetCounter(&htim7);
    };
 //关闭定时器
  HAL_TIM_Base_Stop(&htim7);
}

```

检查两个delay，改为后面注释的us数



```c
void DHT11_Rst(void)
	delay_us(40);     	//主机拉高20~40us
uint8_t DHT11_Read_Bit(void)
	delay_us(40);//等待40us
```



理论上需要自己写读取函数

```c
//从DHT11读取一次数据
uint8_t DHT11_Read_Data(uint8_t *temp, uint8_t *humi)
{
    uint8_t buf[5];
    uint8_t i;
    DHT11_Rst();
    if(DHT11_Check() == 0)
    {
        for(i = 0; i < 5; i++)
        {
            buf[i] = DHT11_Read_Byte();
        }
        if((buf[0] + buf[1] + buf[2] + buf[3]) == buf[4])
        {
            *humi = buf[0];
            *temp = buf[2];
        }
    }
    else return 1;
    return 0;
}
```
初始化方法：

```c
u8	temper ;
u8	humi ;
DHT11_Init();
DHT11_Read_Data(&temper, & humi);
```



### MEMS传感器(LIS302DL)

???



### 光敏电阻（DO）

跳线帽：TRDO

io：配置PA3为输入口

使用：低电平为亮，高电平为不亮

```c
if(!HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_3) )
{
    LCD_DisplayStringLine(Line7, (u8 *)"       DO:High     ");
}
else
{
    LCD_DisplayStringLine(Line7, (u8 *)"       DO:Low      ");
}
```



### 光敏电阻（AO）

跳线帽：TRAO

io：配置ADC2 IN17 Single-end

使用：

```c

tmp = getADC();
sprintf((char *)str,  " R-P:%.2fK  ", tmp / (4096. - tmp) * 10);
```



### AD采集×2

跳线帽：AO1 AO2 对应RP5 RP6 对应PA4 PA5

io：配置ADC2 IN17 Single-end

使用：

#### 官方方法

(例程的写法多少有些暴力)

```c
uint16_t getADC_RP5(void)
{
    ADC_ChannelConfTypeDef sConfig = {0};
    uint16_t adc = 0;
    sConfig.Channel = ADC_CHANNEL_13;
    sConfig.Rank = ADC_REGULAR_RANK_1;
    sConfig.SamplingTime = ADC_SAMPLETIME_640CYCLES_5;
    sConfig.SingleDiff = ADC_SINGLE_ENDED;
    sConfig.OffsetNumber = ADC_OFFSET_NONE;
    sConfig.Offset = 0;
    if (HAL_ADC_ConfigChannel(&hadc2, &sConfig) != HAL_OK)
    {
        Error_Handler();
    }
    HAL_ADC_Start(&hadc2);
    adc = HAL_ADC_GetValue(&hadc2);

    return adc;
}
uint16_t getADC_RP6(void)
{
    ADC_ChannelConfTypeDef sConfig = {0};
    uint16_t adc = 0;
    sConfig.Channel = ADC_CHANNEL_17;
    sConfig.Rank = ADC_REGULAR_RANK_1;
    sConfig.SamplingTime = ADC_SAMPLETIME_640CYCLES_5;
    sConfig.SingleDiff = ADC_SINGLE_ENDED;
    sConfig.OffsetNumber = ADC_OFFSET_NONE;
    sConfig.Offset = 0;
    if (HAL_ADC_ConfigChannel(&hadc2, &sConfig) != HAL_OK)
    {
        Error_Handler();
    }
    HAL_ADC_Start(&hadc2);
    adc = HAL_ADC_GetValue(&hadc2);

    return adc;
}
```

#### AD另法，连续循环DMA

![image-20230606184828637](http://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/202306061848827.png)

![image-20230606162022191](http://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/202306061620343.png)

![image-20230606162215998](http://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/202306061622133.png)

```c
	uint16_t testbuffer[2]={0};
	HAL_ADCEx_Calibration_Start(&hadc2,ADC_SINGLE_ENDED);
	HAL_ADC_Start_DMA(&hadc2,(uint32_t*)&testbuffer,2);
    while (1)
    {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */

        //LCD
		sprintf(tmp,"V1:%.02f",testbuffer[0]/4096.0*3.3);
		LCD_DisplayStringLine(Line1,(uint8_t*)tmp);
		sprintf(tmp,"V2:%.02f",testbuffer[1]/4096.0*3.3);
		LCD_DisplayStringLine(Line2,(uint8_t*)tmp);



    }
  /* USER CODE END 3 */
```

记得是u16存放数据，传进去强转u32

啥？程序好卡(没卡死）？试着把DMA采集ADC的函数注释掉试试。

如果不卡了，那证明就是DMA中断跑的太欢了

关闭DMA全部中断

```c
void MX_DMA_Init(void)
{

  /* DMA controller clock enable */
  __HAL_RCC_DMAMUX1_CLK_ENABLE();
  __HAL_RCC_DMA1_CLK_ENABLE();

  /* DMA interrupt init */
  /* DMA1_Channel1_IRQn interrupt configuration *///注释掉下面这些
//  HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 0, 0);
//  HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
//  /* DMA1_Channel2_IRQn interrupt configuration */
//  HAL_NVIC_SetPriority(DMA1_Channel2_IRQn, 0, 0);
//  HAL_NVIC_EnableIRQ(DMA1_Channel2_IRQn);

}
```

或者直接你可以找找如何默认不开启DMA（在NVIC里）

### 占空比采集

跳线帽：PWM1 PWM2 对应旋钮RP1 RP2 对应PA6 PA7

io：配置TIM3 CH2 上升沿 PSR：170-1 ARR：65535 自动重装关，这样使得CNT为1us加一次

![image-20220516173221072](https://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/image-20220516173221072.png)

使用：

main.c

```c
//启动一次中断先
HAL_TIM_IC_Start_IT(&htim3, TIM_CHANNEL_2);
uint32_t  cc1_value_2 = 0;  									// TIMx_CCR1 的值
uint32_t  RP2 = 0;

void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{

    cc1_value_2 = __HAL_TIM_GET_COUNTER(&htim3);
    __HAL_TIM_SetCounter(&htim3, 0);
    RP2 = 1000000 / cc1_value_2;//频率

    HAL_TIM_IC_Start_IT(&htim3, TIM_CHANNEL_1);
}
```



### 频率采集

跳线帽：PLUSE1 PLUSE2 对应RP3 RP4 对应PA1 PA2

io：配置TIM3 CH2 上升沿 PSR：170-1 ARR：65535 自动重装关，这样使得CNT为1us加一次

![image-20220516173221072](https://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/image-20220516173221072.png)

使用：

main.c

```c
//启动一次中断先
HAL_TIM_IC_Start_IT(&htim3, TIM_CHANNEL_2);
uint32_t  cc1_value_2 = 0;  									// TIMx_CCR1 的值
uint32_t  RP2 = 0;

void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{

    cc1_value_2 = __HAL_TIM_GET_COUNTER(&htim3);
    __HAL_TIM_SetCounter(&htim3, 0);
    RP2 = 1000000 / cc1_value_2;//频率

    HAL_TIM_IC_Start_IT(&htim3, TIM_CHANNEL_1);
}
```

原理如下：

![image-20230406213858677](http://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/202304062138865.png)

**此时CNT不能用TIM->CNT读出，而是读CCR1，CCR2（此时CCR不再是PWM输出时不变的情况）**

所以上述程序要求所捕获的PWM频率不得低于1s/65535us，即15.25Hz，否则由于出现重装不准确，也同时根据采样定理不能高于1s/2us，即500KHz



## 附加内容

### 双路PWM不同频率与占空比

```c++
static int PC1=100,PC4=300,CC1=0,CC4=0;//频率，临时变量
static double ZC1=0.3,ZC4=0.4;//占空比%
static u8 C1=0,C4=0;//高低电平转换	
void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)//重写回调
{
	if(htim->Instance==htim2.Instance)//哪个tim
	{
		if(htim->Channel==HAL_TIM_ACTIVE_CHANNEL_1)//哪个通道
		 {
		   if(C1)
			 {
				 C1=0;//高低电平转换
				 CC1=__HAL_TIM_GET_COUNTER(&htim2)+(int)(1000000/PC1*(1-ZC1));
				 if(CC1>99999)CC1-=99999;//防止CCR>ARR
				 __HAL_TIM_SET_COMPARE(&htim2,TIM_CHANNEL_1,CC1);//设定下一个CCR
			 }
			 else
			 {
				 C1=1;
				 CC1=__HAL_TIM_GET_COUNTER(&htim2)+(int)(1000000/PC1*(ZC1));
				 if(CC1>99999)CC1-=99999;
			 	 __HAL_TIM_SET_COMPARE(&htim2,TIM_CHANNEL_1,CC1);
			 }	 
		 }	
		if(htim->Channel==HAL_TIM_ACTIVE_CHANNEL_4)
		 {
		   if(C4)
			 {
				 C4=0;
				 CC4=__HAL_TIM_GET_COUNTER(&htim2)+(int)(1000000/PC4*(1-ZC4));
				 if(CC4>99999)CC4-=99999;
				 __HAL_TIM_SET_COMPARE(&htim2,TIM_CHANNEL_4,CC4);
			 }
			 else
			 {
				 C4=1;
				 CC4=__HAL_TIM_GET_COUNTER(&htim2)+(int)(1000000/PC4*(ZC4));
				 if(CC4>99999)CC4-=99999;
			 	 __HAL_TIM_SET_COMPARE(&htim2,TIM_CHANNEL_4,CC4);
			 }	 
		 }		 
	}
}	


```

不使用重写回调函数的话，改在IQR里写测试过不行，原因未知

![image-20230328154612568](http://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/202303281546793.png)

OC CH1别开错

![image-20230328154815937](http://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/202303281548028.png)

记得OC的Mode要调整！！！



最后启动OC中断

```c
    HAL_TIM_OC_Start_IT(&htim2,TIM_CHANNEL_1);
    HAL_TIM_OC_Start_IT(&htim2,TIM_CHANNEL_4);
```

直接启动OC IT即可，无需再启动OC

### 捕获双路PWM

```c
u8 CH2Step = 1, CH3Step = 1;
int CH2BUf[3], CH3BUf[3];
void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
  if (htim->Channel == HAL_TIM_ACTIVE_CHANNEL_2)//这里要选择active否则进不去
  {
    if (CH2Step == 1)
    {
      CH2BUf[0] = HAL_TIM_ReadCapturedValue(&htim2, TIM_CHANNEL_2);
      __HAL_TIM_SET_CAPTUREPOLARITY(&htim2, TIM_CHANNEL_2, TIM_ICPOLARITY_FALLING);
      CH2Step++;
    }
    else if (CH2Step == 2)
    {
      CH2BUf[1] = HAL_TIM_ReadCapturedValue(&htim2, TIM_CHANNEL_2);
      __HAL_TIM_SET_CAPTUREPOLARITY(&htim2, TIM_CHANNEL_2, TIM_ICPOLARITY_RISING);
      CH2Step++;
    }
    else if (CH2Step == 3)
    {
      CH2BUf[2] = HAL_TIM_ReadCapturedValue(&htim2, TIM_CHANNEL_2);
      __HAL_TIM_SET_CAPTUREPOLARITY(&htim2, TIM_CHANNEL_2, TIM_ICPOLARITY_FALLING);
      CH2Step++;
      HAL_TIM_IC_Stop_IT(&htim2, TIM_CHANNEL_2);
    }
  }
  else
  {
    if (CH3Step == 1)
    {
      CH3BUf[0] = HAL_TIM_ReadCapturedValue(&htim2, TIM_CHANNEL_3);
      __HAL_TIM_SET_CAPTUREPOLARITY(&htim2, TIM_CHANNEL_3, TIM_ICPOLARITY_FALLING);
      CH3Step++;
    }
    else if (CH3Step == 2)
    {
      CH3BUf[1] = HAL_TIM_ReadCapturedValue(&htim2, TIM_CHANNEL_3);
      __HAL_TIM_SET_CAPTUREPOLARITY(&htim2, TIM_CHANNEL_3, TIM_ICPOLARITY_RISING);
      CH3Step++;
    }
    else if (CH3Step == 3)
    {
      CH3BUf[2] = HAL_TIM_ReadCapturedValue(&htim2, TIM_CHANNEL_3);
      __HAL_TIM_SET_CAPTUREPOLARITY(&htim2, TIM_CHANNEL_3, TIM_ICPOLARITY_FALLING);
      CH3Step++;
      HAL_TIM_IC_Stop_IT(&htim2, TIM_CHANNEL_3);
    }
  }
}
```



```c
int main(void)
{
  HAL_TIM_IC_Start_IT(&htim2, TIM_CHANNEL_2);
  HAL_TIM_IC_Start_IT(&htim2, TIM_CHANNEL_3);
  double fp2 = 0, fp3 = 0;
  double zhan2 = 0, zhan3 = 0;
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
    if (CH2Step == 4)
    {
      CH2Step = 1;
      fp2 =  1/((double)(CH2BUf[2] - CH2BUf[0])/1000000.0);
      zhan2 = (double)(CH2BUf[1] - CH2BUf[0]) / (double)(CH2BUf[2] - CH2BUf[0]);
      memset(CH2BUf, 0, sizeof(CH2BUf));	
//      __HAL_TIM_SET_COUNTER(&htim2, 0);
      __HAL_TIM_SET_CAPTUREPOLARITY(&htim2, TIM_CHANNEL_2, TIM_ICPOLARITY_RISING);
      HAL_TIM_IC_Start_IT(&htim2, TIM_CHANNEL_2);
    }
    if (CH3Step == 4)
    {
      CH3Step = 1;
      fp3 = 1/((double)(CH3BUf[2] - CH3BUf[0])/1000000.0);
      zhan3 = (double)(CH3BUf[1] - CH3BUf[0]) / (double)(CH3BUf[2] - CH3BUf[0]);
      __HAL_TIM_SET_CAPTUREPOLARITY(&htim2, TIM_CHANNEL_3, TIM_ICPOLARITY_RISING);
      HAL_TIM_IC_Start_IT(&htim2, TIM_CHANNEL_3);
    }
  }
```

使用的是TIM2，拥有u32的ARR计数器，所以可测量的频率下限很低很低，也不需要考虑更新中断带来的影响

记得测试时高电平要3.2v左右，2.2v测试时会乱跳

![image-20230407122157033](http://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/202304071221225.png)

![image-20230407122205569](http://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/202304071222706.png)

### 另一种双路捕获的办法（存在硬件限制但不多）

1 2通道一组，3 4通道一组

举例1：CH1采集输入

https://blog.csdn.net/qq_29031103/article/details/120023388

![img](http://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/202306091752957.png)

![img](http://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/202306091752949.png)

（此处时PSC自己改为160-1等，保证为1us)

![img](http://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/202306091752925.png)

![img](http://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/202306091752677.png)

**此处只有一个口才是对的，才是对的**

```c
//初始化
HAL_TIM_IC_Start_IT(&htim8,TIM_CHANNEL_1);
HAL_TIM_IC_Start_IT(&htim8,TIM_CHANNEL_2);
while(1)
{
    sprintf(tmp, "   %.2f  %.2f  ", Duty, Frequency);
    LCD_DisplayStringLine(Line8, (uint8_t *)(tmp));
}

//中断回调
float Duty, Frequency;
int Cap_val1, Cap_val2;
void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
	if(htim.Channel==HAL_TIM_ACTIVE_CHANNEL_1)
	{
		Cap_val1=HAL_TIM_ReadCapturedValue(&htim4,TIM_CHANNEL_1);
		Cap_val2=HAL_TIM_ReadCapturedValue(&htim4,TIM_CHANNEL_2);
		if(Cap_val1!=0)
		{
			Duty=(float)(Cap_val2+1)*100/(Cap_val1+1);
			F=170000000/170/(float)(Cap_val1+1);
		}
	}
}
```

那如果是CH2接收呢？

![image-20230609180600103](http://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/202306091806247.png)

![image-20230609180618466](http://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/202306091806613.png)

![image-20230609180805877](http://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/202306091808016.png)

![image-20230609180821260](http://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/202306091808394.png)

![image-20230609180902747](http://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/202306091809888.png)

```c
float Duty, Frequency;
int Cap_val1, Cap_val2;
void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
  if (htim->Channel == HAL_TIM_ACTIVE_CHANNEL_2)//对应输入的通道
  {
    /*读取寄存器的值*/
    Cap_val1 = HAL_TIM_ReadCapturedValue(&htim2, TIM_CHANNEL_2);//val1 对应输入的通道
    Cap_val2 = HAL_TIM_ReadCapturedValue(&htim2, TIM_CHANNEL_1);
    /*计算占空比，频率*/
    if (Cap_val1 != 0)
    {
      Duty = (float)(Cap_val2 + 1) * 100 / (Cap_val1 + 1);
      Frequency = 1000000 / (float)(Cap_val1 + 1);
    }
  }
}
```



### CHXN用法

很奇怪，但是如下使用

![image-20230407213658307](http://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/202304072136465.png)

![image-20230407213736687](http://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/202304072137810.png)

下面其实不用改

如上就可以当正常的PWM输出

### SRAM？

![image-20230609184458069](http://github.xutongxin.me/https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/202306091844243.png)

### 移位

```c
&=~（1<<3）
```

使得第四位清零

```c
|=(1<<1)
```

使得第二位置位

```c
^=(1<<2)
```

使得第三位翻转

### 使定时器接近精确的重设

```c++
TIM2->CNT=0;
TIM2->SR=0;//https://blog.csdn.net/weixin_44788542/article/details/113111139
HAL_TIM_Base_Start_IT(&htim2);
```

### 关于时钟

160MHz可能更好，因为能做到整除4,8等数据，而不是170MHz

### 关于屏幕显示

小心百分号

```c
sprintf("%%")
```



## 来自xtx的最后碎碎念

虽然但是，xtx也是拿过国一的

以下是几个最值得参考的程序

project2023\xtx\GuoSai\Base 这个文件夹里面是国赛（包含拓展板驱动的）基准编写项目文件夹（就是说没有功能只有驱动和模板）

project2023\xtx\GuoSai\14 国一程序

project2023\xtx\ShengSai\14 省一程序



## 等待你们的碎碎念

