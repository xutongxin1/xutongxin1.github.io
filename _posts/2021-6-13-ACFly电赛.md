仍然是纯笔记

![image-20210613125443745](https://raw.githubusercontent.com/xutongxin1/xutongxin1.github.io/master/asset/%E6%97%A5%E5%BF%97/image-20210613125443745.png)

默认飞完一个定点飞行后会进入位置锁定模式

位置移动有多个模式

![image-20210613125805126](https://raw.githubusercontent.com/xutongxin1/xutongxin1.github.io/master/asset/%E6%97%A5%E5%BF%97/image-20210613125805126.png)

延时也是老延时了

![image-20210613125556860](https://raw.githubusercontent.com/xutongxin1/xutongxin1.github.io/master/asset/%E6%97%A5%E5%BF%97/image-20210613125556860.png)

**但是不能这么写**，会导致全系统暂停

任务模式执行有个频率

![image-20210613132409180](https://raw.githubusercontent.com/xutongxin1/xutongxin1.github.io/master/asset/%E6%97%A5%E5%BF%97/image-20210613132409180.png)

为了延时2s，应该写

![image-20210613132505881](https://raw.githubusercontent.com/xutongxin1/xutongxin1.github.io/master/asset/%E6%97%A5%E5%BF%97/image-20210613132505881.png)

同时**XY轴是基于坐北向南建立的**



在M01_Ground.c中有模式进入模式选择代码

![image-20210720155550257](https://raw.githubusercontent.com/xutongxin1/xutongxin1.github.io/master/asset/%E6%97%A5%E5%BF%97/image-20210720155550257.png)

M30 姿态模式

M32 位置模式

单位全部是**cm厘米**

## 向上光流

![image-20210724144630824](https://raw.githubusercontent.com/xutongxin1/xutongxin1.github.io/master/asset/%E6%97%A5%E5%BF%97/image-20210724144630824.png)

##  RCdata表示

rc->data[0];//油门

rc->data[1];//偏航（左右）

rc->data[2];//倾斜（前后）

rc->data[3];//横滚

rc->data[4];//模式杆，最上面为0

rc->data[5];//开关杆





## 解析巡线例程，看串口实现

首先是Uart读取和数据点的解析

在Drivers\drv_SDI.c中实现

![image-20210721185951641](https://raw.githubusercontent.com/xutongxin1/xutongxin1.github.io/master/asset/%E6%97%A5%E5%BF%97/image-20210721185951641.png)

（图片最下面一行开始读入uart原始数据，检查uart3的定义可知是给openmv用的）

然后M35使用了SDI数据

直接使用时转换为了角度和速度

![image-20210721190123131](https://raw.githubusercontent.com/xutongxin1/xutongxin1.github.io/master/asset/%E6%97%A5%E5%BF%97/image-20210721190123131.png)

那接下来就是要分析一下openmv是怎么发送的了

https://book.openmv.cc/example/09-Feature-Detection/linear-regression-fast.html   这个是车巡线，其实原理基本一致

https://openmv.io/blogs/news/linear-regression-line-following 各个参数定义

![img](https://raw.githubusercontent.com/xutongxin1/xutongxin1.github.io/master/asset/%E6%97%A5%E5%BF%97/polar.png)

然后发现自己对题目的理解有误？！

。。。。

但是串口的方案也算是确认下来了



## 任务队列

```c++
//添加任务函数，返回任务ID

//如任务模式为时间触发，t为触发时间间隔

//如任务模式为自定义函数触发，trigger_func为自定义函数

//mainfunc为任务主函数

unsigned int STS_Add_Task( STS_Task_Trigger_Mode mode , float t , bool (*trigger_func)( unsigned int Task_ID ) , void (*mainfunc)( unsigned int Task_ID ) )
```

此时再看

```c++
void init_drv_SDI2()

{

  STS_Add_Task( STS_Task_Trigger_Mode_Custom , 0 , SDI_RCTrigger , SDI_Server );
	//名为STS_Task_Trigger_Mode_Custom，不是使用时间触发（0），使用SDI_RCTrigger函数触发SDI_Server
}
```

```c++
static bool SDI_RCTrigger( unsigned int Task_ID )//触发函数，该函数似乎会自动触发执行，然后再尝试调用SDI_Server
{
	if( UART2_DataAvailable() )
		return true;
	return false;
}
```

那我只需要思考如何编写SDI_Server即可了



### %5.1f是什么意思
表示保留1位小数总长度为5个字节的的浮点数

%f表示输出为单精度浮点数
5表示总长度为5，包括小数点
小数点后面是1表示保留一位小数，如果是%5.2f则保留两位小数

## Undefined symbol

![image-20210724144700451](https://raw.githubusercontent.com/xutongxin1/xutongxin1.github.io/master/asset/%E6%97%A5%E5%BF%97/image-20210724144700451.png)

最终解决办法是在对应的.h文件再extern一遍

逻辑如下：

A.c：int num=0;

A.h:  extern int num;

B.h: #include 'A.h'

​		extern int num;

B.c num=。。。

## 正反桨

先不装桨看电机转向，然后装桨

**不是字朝上就是装对了！**

![img](https://raw.githubusercontent.com/xutongxin1/xutongxin1.github.io/master/asset/%E6%97%A5%E5%BF%97/420A70DA78BA3209754C7045CCDB8C2F.jpg)

## 增添Uart7的驱动

先把uart2.c.h SDI2.c.h复制

然后把文件里所有UART2改为UART7

**除了！**

```c++
SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOE);
//检查数据手册看看pin脚在哪个区
```

![image-20210724191801291](https://raw.githubusercontent.com/xutongxin1/xutongxin1.github.io/master/asset/%E6%97%A5%E5%BF%97/image-20210724191801291.png)

```c++
uDMAChannelAssign(UDMA_CH21_UART7TX );  
//DMA通道
```

```c++
IntPrioritySet( INT_UART7 , INT_PRIO_7 );//中断线，好像无意间选对了
```

基本都是查改宏定义的事情

## Uart发送数字

以前就老想知道怎么写比较好

感觉写转换不是个很好的办法

现在知道了

```c++
char num_str[8];

sprintf( num_str , "%5.1f" ,ultra_height);

Uart7_Send(&num_str,sizeof(num_str));

Uart7_Send("\r\n",2);
```

## PWM输出

![image-20210726145133796](https://raw.githubusercontent.com/xutongxin1/xutongxin1.github.io/master/asset/%E6%97%A5%E5%BF%97/image-20210726145133796.png)

注意此时的pwmgen应该是类似于tim123的样子，不是pwm通道

所以没有PWM_GEN_4的定义

![image-20210726145246895](https://raw.githubusercontent.com/xutongxin1/xutongxin1.github.io/master/asset/%E6%97%A5%E5%BF%97/image-20210726145246895.png)

最后三句：启动PWM，全部拉低，开启高电平

**但是**

PWM_OUT_4和PWM4不是一个接口。

程序中的PWM定义最终反映到以这个图为准

（左边是程序定义的pwm，右边是飞控手册上定义的pwm）

所以PWM_OUT_4实际对应是手册上的PWM8

![image-20210728191755878](https://raw.githubusercontent.com/xutongxin1/xutongxin1.github.io/master/asset/%E6%97%A5%E5%BF%97/image-20210728191755878.png)



## 飞控openmv通信

```python
    sumA = 0

​    sumB = 0

​    data = bytearray([0x41,0x43])#包头AC

​    uart.write(data)



​    data = bytearray([0x02,8])#消息类别2，数据长度为8（两个Float大小为8），注意随着数据点增加而改变，建议最大4个数据点否则飞控侧需要改代码

​    for b in data:

​      sumB = sumB + b

​      sumA = sumA + sumB

​    uart.write(data)



​    float_value = theta_err

​    float_bytes = pack('f', float_value)

​    for b in float_bytes:

​      sumB = sumB + b

​      sumA = sumA + sumB

​    uart.write(float_bytes)#角度偏差



​    float_value = rho_err*0.1

​    float_bytes = pack('f', float_value)

​    for b in float_bytes:

​      sumB = sumB + b

​      sumA = sumA + sumB

​    uart.write(float_bytes)#距离偏差



​    data = bytearray([sumB, sumA])#校验

​    #该校验不是一般的奇偶校验！！！

​    uart.write(data)



​    print(float_value,theta_err)
```



## M32

位置锁定模式

需要进入该模式后同时把任务杆打到最低

![image-20210727144044496](https://raw.githubusercontent.com/xutongxin1/xutongxin1.github.io/master/asset/%E6%97%A5%E5%BF%97/image-20210727144044496.png)

## M35

对所有的API，X轴是前后，Y轴是左右

完成一段飞行后会自动回到Position_ControlMode_Position位置锁定模式

所以在状态机处只需要写

```c++
if( get_Position_ControlMode() == Position_ControlMode_Position )
{
    
}
```

即可用于确定上一个飞行命令执行结束
