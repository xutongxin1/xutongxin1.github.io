---

layout: post
title: 两轮平衡小车探索
categories: 日志
tags: 
    - 开发 
    - 开发任务
BGImage: 'https://raw.githubusercontent.com/xutongxin1/xutongxin1.github.io/master/asset/%E6%97%A5%E5%BF%97/20201220234325.png'
jekyll-theme-WuK:
    musicid: '744590'

---

# 16周

## 12.20

收到任务的第0天

首先平衡小车的样子大概是这样的

![image-20201221002640667](C:%5CUsers%5C%E6%98%9F%E6%98%9F%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201221002640667.png)

这个是独轮子的，我可以降低难度用双轮子的，这样上面的平衡轮（好像我以前叫飞轮，产生左右动量的）就可以省略

那么前后就靠水平传感器来判断（但是这个检测周期必须快）

那么目前的任务点比较模糊但是可以先收集资料

- [ ] 观看别人视频
- [ ] 找一块驱动板



本项目目前认为有以下难点

1. AD应用
2. PID算法
3. 电控的算法逻辑
4. 避障功能的实现
5. 遥控功能的实现



![image-20201221003447021](https://raw.githubusercontent.com/xutongxin1/xutongxin1.github.io/master/asset/%E6%97%A5%E5%BF%97/2020image-20201221003447021.png)

最后就是这次需要好好用todo任务列表了



## 12.21

确定方向

采用无刷电机和tb6612驱动板

做两轮的平衡小车

今天看完了PID



### PID

**P**：比例，在计算中是输出=Kp*误差值。Kp越大误差调整越快（因为调整的力度大了），但是只有P容易过度（刹车不了，超过标准）

**D**：微分，在计算中距离对时间微分得到速度，越接近微分速度越小

**I**  ：积分，在运动中对误差积分，并防止最后的误差无法被缩小（存在外界摩擦风力等情况下）



个人感觉这个教程不错：

https://b23.tv/MyCc8f



PID实例图

![img](https://raw.githubusercontent.com/xutongxin1/xutongxin1.github.io/master/asset/%E6%97%A5%E5%BF%97/0586623DCBF0F12819255C38C43904A5.png)

通过获取e（误差），用PID算法算出所需的运行速度V，并且运行一下继续重新获得e

但是会出你想要的速度不是实际的速度（因为阻力是不确定的，不是你给一个对应的PWM就可以到对应速度）

所以需要多级PID

![img](https://raw.githubusercontent.com/xutongxin1/xutongxin1.github.io/master/asset/%E6%97%A5%E5%BF%97/1FC5D7E6F05067CD766A7808A214F1B8.png)

嵌套入速度PID的PWM调控方案！

还有一重是电流PID（不过可以不需要，对精度要求不高时），防止对电机的瞬时扭矩提出过高要求

速度获取需要编码器（终于明白它在PID的重要性）

## 12.22

大概了解了下

独轮小车确实比两轮的的难做不少

同时还要考虑转弯的算法

计划这两天试试搞个原理图



## 12.23

最小系统板的原理图怎么搞？

**FOC（Field-Oriented Control）**，直译是磁场定向控制，也被称作矢量控制**（VC，Vector Control）**，是目前无刷直流电机（BLDC）和永磁同步电机（PMSM）高效控制的最优方法之一。FOC旨在通过精确地控制磁场大小与方向，使得电机的运动转矩平稳、噪声小、效率高，并且具有高速的动态响应。

简单来说就是，FOC是一种对无刷电机的驱动控制方法，它可以让我们对无刷电机进行“**像素级”**控制，实现很多传统电机控制方法（比如电调）所无法达到的效果~

**FOC的优势：**

1. **低转速下控制**
   由于控制原理的区别，无刷电调只能控制电机工作在高转速下，低速下无法控制；而FOC控制器则完全没有这个限制，不论在什么转速下都可以实现精确控制。
2. **电机换向**
   同上面的理由，由于电调无法反馈转子位置，因此很难实现电机正反转的换向（当然有感电调可以实现）；而FOC驱动器的换向性能极其优秀，最高转速下正反转切换可以非常顺畅；此外FOC还可以以能量回收的形式进行刹车控制。
3. **力矩控制**
   普通电调都只能控制电机转速，而FOC可以进行电流（力矩）、速度、位置三个闭环控制。
4. **噪音**
   FOC驱动器的噪音会比电调小很多，原因是普通电调采用方波驱动，而FOC是正弦波。

**电调的优势：**

1. **兼容性**
   电调驱动不同的BLDC不需要进行参数整定，而FOC需要。
2. **算法复杂度**
   电调的算法实现更简单，运算量少，很适合需要提高带宽的超高转速电机。
3. **成本**
   电调的成本比FOC低很多。

综上大家应该可以看出来，FOC驱动器在控制性能上是要比电调强大得多的，其优异的性能和**磁场定向控制**的原理是密不可分的，下面就会详细介绍FOC控制的实现方法。



## 12.24

生日不是不干活的理由啦，不过今天确实不会那么忙

**AD的自动编号**

工具-> 标注->原理图标注

![img](https://raw.githubusercontent.com/xutongxin1/xutongxin1.github.io/master/asset/%E6%97%A5%E5%BF%97/20191022134941450.png)

**USB-C使用**

USB-C有很多脚的版本，最多24脚（12*2），而且难以焊接。在平时开发中如果需要使用，可以直接选择现成引出引脚的PCB板

![img](https://raw.githubusercontent.com/xutongxin1/xutongxin1.github.io/master/asset/%E6%97%A5%E5%BF%97/O1CN01mwJqnn1OR6LThkMWY_!!409131701.jpg)

D+和D-是USB 2.0差分信号，详情可以看这个

https://zh.wikipedia.org/wiki/USB_Type-C

同时如果涉及到USB接口布线规则可以看这个

https://zhuanlan.zhihu.com/p/76836808

**保险丝的使用**

保险丝一般用于输出原件后（比如电池后面），但是如果电源模块过于廉价也没有用保险的必要。Stm32等信号端一般没有用保险丝的意义

**led放置**

为了放置流经LED二极管电流过大，如果是3.3v接500欧电阻，5v接1K电阻

（LED灯一般流经电流10mA，电压大于3v左右就会亮）



## 12.25

圣诞节哦

AD的改图进入了第二版，总结一下第一版出现的问题

![image-20201225192927810](https://raw.githubusercontent.com/xutongxin1/xutongxin1.github.io/master/asset/%E6%97%A5%E5%BF%97/image-20201225192927810.png)

应该要这样标注管脚名称

而不是这样

![image-20201225193117949](https://raw.githubusercontent.com/xutongxin1/xutongxin1.github.io/master/asset/%E6%97%A5%E5%BF%97/image-20201225193117949.png)

用什么管脚才标记什么，不用全都标

一般也不用连线，而是直接标记就好



# 17周

## 12.29

刚考完试继续看

AD改图仍在继续

选元件（Component）的地方可以改封装再拖出来

![image-20201229211656621](https://raw.githubusercontent.com/xutongxin1/xutongxin1.github.io/master/asset/%E6%97%A5%E5%BF%97/image-20201229211656621.png)

也可以在选完之后的选项里改

（footprint）

![image-20201229211750553](https://raw.githubusercontent.com/xutongxin1/xutongxin1.github.io/master/asset/%E6%97%A5%E5%BF%97/image-20201229211750553.png)

至于封装管理器，抱歉确实有些问题没弄好，先放着不用吧



船型开关比较好应对大电流（如电机）

而自锁开关一般用于单片机电源



#### stm32cubeMX名词

Asynchronous(异步通信)和Synchronous(同步通信)的区别

https://blog.csdn.net/spdian/article/details/71215467

如果仅使用上的区别，就同步通信需要同步时钟，但是通信速度加快



Clock Source里的Internal Clock（内部时钟） ，另外一个ETR2是外部触发输入 。




## 12.30 

### I2C

个人翻译就是一个内存互访协议

但是一般都是单方面发起访问

可以读也可以写

而且有稳定性，通用性等优势



### DMA

允许不同速度的硬件装置来沟通，而不需要依赖于CPU的大量中断负载

与I2C不同，它可用于设备内的内存与缓存区之间

## 18周

### 1.6

新年来了，又过了，继续写吧

目前打算是用的小车底盘

虽然确实挺贵的，但是也是为了买教程减少开发弯路吧

小车底盘上自带了编码器，我的磁性编码器就可以暂时不用了，但是这两周有机会还是会试一下的

### 1.9

小车底盘到了，首先是编码器从霍尔传感类变成了光栅类，虽然精度大大降低了（原来是0.03度，现在是0.7度）但是仍然很高

编码器的输出也不再是pwm或者i2c连接了，变成了AB相输出

AB相交叉输出电信号，每一个信号就像一个台阶，只要统计每分钟台阶数目就可以测出速度了

统计台阶的话转化为程序逻辑就是统计电平上升沿数量，即每当电平上升沿就进入中断，中断中把变量+1，再来个tim定时器每秒定时输出变量数值除以光栅数量就是每秒转了几圈就可以算出速度了

然后很方便的，cubemx里可以



## 1.30

出乎意料的，今天在帮myy解决led不亮的问题时，看到的电路图是这样的

![image-20210130113620501](https://raw.githubusercontent.com/xutongxin1/xutongxin1.github.io/master/asset/%E6%97%A5%E5%BF%97/2020image-20210130113620501.png)

然后就想着，把PC13变成接地就好了嘛->就改成input嘛->怎么不亮？？？

怎么改成output拉低就可以了

然后开始检查自己的知识盲区是否存在

果然

https://blog.csdn.net/qq_38410730/article/details/79858906

这个文章很详细的解释了所有io模式的原理

同时

http://murata.eetrend.com/article/2017-10/1000901.html

VCC,VDD,VEE,VSS的解释

所以input不能当地

而output的low就是等效地，然后电势差点亮了灯



## 2.1

日常debug

满心欢喜的拿着别人的库准备测试，啥代码检查错误不报，编译时搞了个

```cmake
No rule to make target `***', needed by `****'.  Stop.
```

你以为是库爆炸了

实际上你需要

**重载cmake即可**

（此问题仅限你在clion开发stm32的hal库开发时，可能的解决方案）

（如果还是无法解决问题，可以看看https://blog.csdn.net/wangcg123/article/details/77412636）



第二个bug

```cmake
[  7%] Building C object CMakeFiles/mpu6050Test.elf.dir/Core/Src/MPU6050/I2C.c.obj
[  7%] Building C object CMakeFiles/mpu6050Test.elf.dir/Core/Src/MPU6050/inv_mpu.c.obj
[ 10%] Building C object CMakeFiles/mpu6050Test.elf.dir/Core/Src/MPU6050/inv_mpu_dmp_motion_driver.c.obj
In file included from E:\GitProject\stm32\mpu6050Test\Drivers\STM32F1xx_HAL_Driver\Inc/stm32f1xx_hal_rcc.h:1144,
                 from E:\GitProject\stm32\mpu6050Test\Core\Inc/stm32f1xx_hal_conf.h:237,
                 from E:\GitProject\stm32\mpu6050Test\Drivers\STM32F1xx_HAL_Driver\Inc/stm32f1xx_hal.h:30,
                 from E:\GitProject\stm32\mpu6050Test\Drivers\CMSIS\Device\ST\STM32F1xx\Include/stm32f1xx.h:200,
                 from E:\GitProject\stm32\mpu6050Test\Drivers\STM32F1xx_HAL_Driver\Inc/stm32f1xx_hal_def.h:30,
                 from E:\GitProject\stm32\mpu6050Test\Core\Inc/MPU6050/I2C.h:1,
                 from E:\GitProject\stm32\mpu6050Test\Core\Src\MPU6050\I2C.c:1:
E:\GitProject\stm32\mpu6050Test\Drivers\STM32F1xx_HAL_Driver\Inc/stm32f1xx_hal_rcc_ex.h:1859:1: error: unknown type name 'HAL_StatusTypeDef'; did you mean 'FLASH_TypeDef'?
 HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit);
 ^~~~~~~~~~~~~~~~~
 FLASH_TypeDef
```

而且有很多同类错误，在外网摸索后发现了问题来源

```c
#include <stm32f1xx_hal_def.h>
#include <stm32f1xx_hal_conf.h>
#include "stm32f1xx_hal.h"//然而我包含上面两个
```

换而言之，被重复引用了。按照论坛说法

```
不必包括特定的HAL部分（在我的情况下为#include“ stm32f7xx_hal_gpio.h”），而仅需包括完整的HAL标头（#include“ stm32f7xx_hal.h”）。
```

所以把

```
#include <stm32f1xx_hal_def.h>
#include <stm32f1xx_hal_conf.h>
```

删去即可

同时这个错误不止发生在有

```
#include "stm32f1xx_hal.h" 
```

的情况中

```cmake
[  7%] Building C object CMakeFiles/mpu6050Test.elf.dir/Core/Src/MPU6050/I2C.c.obj
[  7%] Building C object CMakeFiles/mpu6050Test.elf.dir/Core/Src/MPU6050/inv_mpu.c.obj
[ 10%] Building C object CMakeFiles/mpu6050Test.elf.dir/Core/Src/MPU6050/inv_mpu_dmp_motion_driver.c.obj
In file included from E:\GitProject\stm32\mpu6050Test\Drivers\STM32F1xx_HAL_Driver\Inc/stm32f1xx_hal_rcc.h:1144,
                 from E:\GitProject\stm32\mpu6050Test\Core\Inc/stm32f1xx_hal_conf.h:237,
                 from E:\GitProject\stm32\mpu6050Test\Drivers\STM32F1xx_HAL_Driver\Inc/stm32f1xx_hal.h:30,
                 from E:\GitProject\stm32\mpu6050Test\Drivers\CMSIS\Device\ST\STM32F1xx\Include/stm32f1xx.h:200,
                 from E:\GitProject\stm32\mpu6050Test\Drivers\STM32F1xx_HAL_Driver\Inc/stm32f1xx_hal_def.h:30,
                 from E:\GitProject\stm32\mpu6050Test\Core\Inc/MPU6050/I2C.h:1,
                 from E:\GitProject\stm32\mpu6050Test\Core\Src\MPU6050\I2C.c:1:
E:\GitProject\stm32\mpu6050Test\Drivers\STM32F1xx_HAL_Driver\Inc/stm32f1xx_hal_rcc_ex.h:1859:1: error: unknown type name 'HAL_StatusTypeDef'; did you mean 'FLASH_TypeDef'?
 HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit);
 ^~~~~~~~~~~~~~~~~
 FLASH_TypeDef
```

而且有很多同类错误，在外网摸索后发现了问题来源

```c
#include <stm32f1xx_hal_def.h>
#include <stm32f1xx_hal_conf.h>
#include "stm32f1xx_hal.h"//然而我包含上面两个
```

换而言之，被重复引用了。按照论坛说法

```
不必包括特定的HAL部分（在我的情况下为#include“ stm32f7xx_hal_gpio.h”），而仅需包括完整的HAL标头（#include“ stm32f7xx_hal.h”）。
```

所以把

```c
#include <stm32f1xx_hal_def.h>
#include <stm32f1xx_hal_conf.h>
```

删去即可

同时这个错误不止发生在有

```c
#include "stm32f1xx_hal.h" 
```

的情况中，还可能出现在

```cmake
[  3%] Building C object CMakeFiles/mpu6050Test.elf.dir/Core/Src/MPU6050/mpu6050.c.obj
In file included from E:\GitProject\stm32\mpu6050Test\Core\Src\MPU6050\mpu6050.c:1:
E:\GitProject\stm32\mpu6050Test\Drivers\CMSIS\Include/core_armv8mbl.h:1252:39: error: unknown type name 'IRQn_Type'; did you mean 'IPSR_Type'?
 __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
                                       ^~~~~~~~~
                                       IPSR_Type
```

这种错误的解决是删去

```c
#include <core_armv8mbl.h>
```

即可



最后来解决个warning

```shell
[  3%] Building C object CMakeFiles/mpu6050Test.elf.dir/Core/Src/MPU6050/mpu6050.c.obj
In file included from E:\GitProject\stm32\mpu6050Test\Core\Src\MPU6050\mpu6050.c:3:
E:\GitProject\stm32\mpu6050Test\Core\Inc/MPU6050/I2C.h:16: warning: "UNUSED" redefined
 #define UNUSED(x) ((void)(x))

In file included from E:\GitProject\stm32\mpu6050Test\Drivers\STM32F1xx_HAL_Driver\Inc/stm32f1xx_hal_rcc.h:29,
                 from E:\GitProject\stm32\mpu6050Test\Core\Inc/stm32f1xx_hal_conf.h:237,
                 from E:\GitProject\stm32\mpu6050Test\Drivers\STM32F1xx_HAL_Driver\Inc/stm32f1xx_hal.h:30,
                 from E:\GitProject\stm32\mpu6050Test\Core\Inc/MPU6050/I2C.h:2,
                 from E:\GitProject\stm32\mpu6050Test\Core\Src\MPU6050\mpu6050.c:3:
E:\GitProject\stm32\mpu6050Test\Drivers\STM32F1xx_HAL_Driver\Inc/stm32f1xx_hal_def.h:68: note: this is the location of the previous definition
 #define UNUSED(X) (void)X      /* To avoid gcc/g++ warnings */
```

就是被重复定义了，删掉#define UNUSED(x) ((void)(x))即可



## 2.2

代码笔记

printf重定向

```c
/* USER CODE BEGIN Includes */
#include <stdio.h>
extern UART_HandleTypeDef huart1;   //声明串口
/* USER CODE END Includes */
```

```c
/* USER CODE BEGIN 0 */
#ifdef __GNUC__

#define PUTCHAR_PROTOTYPE int __io_putchar(int ch)

PUTCHAR_PROTOTYPE
{
    //注意下面第一个参数是&husart1，因为cubemx配置了串口1自动生成的
    HAL_UART_Transmit(&huart1 ,(uint8_t*)&ch, 1, HAL_MAX_DELAY);
    return ch;
}
#endif
/* USER CODE END 0 */
```

回车换行问题，顺带重新记一下串口发送

```
'\r’是回车，前者使光标到行首
'\n’是换行，后者使光标下移一格

Unix系统里，每行结尾只有“<换行>”，即“\n”；
Windows系统里面，每行结尾是“<回车><换行>”，即“\r\n”；
Mac系统里，每行结尾是“<回车>”,即“\r

From：https://blog.csdn.net/M_Pinery/article/details/86308004
```

```c
char RxBuffer[100]="Hello\r\n";
HAL_UART_Transmit(&huart1, (uint8_t *)&RxBuffer, sizeof(RxBuffer),0xFFFF);
```

而且测试得出先\r还是先\n好像结果一样，但是必须两个都要有