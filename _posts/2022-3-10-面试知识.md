

### float浮点型变量在计算机内存中占用4字节（Byte）,即32-bit。

一个浮点数由2部分组成：底数m 和 指数e。

https://blog.51cto.com/clown5/1710036

### float 和 char 

float：占4个字节
double： 占8个字节

double 和 float 的区别是double精度高，有效数字16位，float精度7位（可提供7位或8位有效数字，构成包括符号位、指数位和尾数位）。

但double消耗内存是float的两倍，double的运算速度比float慢得多，能用单精度时不要用双精度。



### 软件开发框架

[浅谈 C/S 和 B/S 架构](https://developer.aliyun.com/article/23889)

client/server/browser

### char 的地址32位下4字节，64位下8字节

https://blog.csdn.net/qq_18297675/article/details/50532267

### 在C语言中，如果一些函数被频繁调用，不断地有函数入栈，即**函数栈**，会造成栈空间或**栈内存**的大量消耗。

​    为了解决这个问题，特别的引入了**inline修饰符**，表示为**内联函数**



### const

const只读变量

　　const修饰的变量是只读的。本质还是变量

　　const修饰的局部变量在栈上分配空间

　　const修饰的全局变量在全局数据区分配空间

　　const只在编译期有用，在运行期无用

　　const修饰的变量不是真的变量，它只是告诉

　　编译器该变量不能出现在赋值符号的左边

const修饰函数参数和返回值　

　　-const修饰函数参数表示在函数体内不希望改变参数的值

　　-const修饰函数返回值表示返回值不可改变，多用于返回指针的情形

小贴士：

　　-C语言中的字符串字面量存储于只读存储区，

　　-在程序中需要使用 const char* 指针。

volatile可理解为“编译器警告提示符”

​      volatile告诉编译器必须每次去内存中取变量值

​      volatile主要修饰可能被多个线程访问的变量

​      volatile也可以修饰可能被未知因数更改的变量



小结：

  const使得变量具有只读属性

​        const不能定义真正意义上的常量

​        const将具有全局生命期的变量存储于只读存储区

​        volatile强制编译器减少优化，必须每次到内存中取值

![img](https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/1554553-20181215143924805-251298056.png)

### 怎么样统计已经实例化的对象数目 （弄个全局计数器，构造函数里 计数器+1）不喜欢全局变量，不好管理 怎么弄（没想到，然后面试官给了提示是用 类内声明静态变量）

### 学过哪些容器 说一下 （就那几个呗）
现在我有个需求，要反复增删容器内的值，而且可以在头尾增删，选哪个容
器，说说理由 （头尾增删，deque咯）
从性能的角度再来说说 为什么选你选的这个 （因为vector，从头部删，要把
原来的值都往后移，底层要多了很多步工序）

### 从汇编的角度来说说 i++和 ++i 性能上的差异
（一开始没想到，然后提示说两个数做加法运算，就是把两个数分别存
到寄存器，再相加）
（那我可就来劲了，i++是先执行完指令再+，++i是加完再执行后面的指
令，执行别的指令又要重新读写寄存器，那肯定++i高嘛）





### C++三大特性

https://blog.csdn.net/qq_38378284/article/details/100709808

**封装：**

把方法封装再类里增加安全性，提升对变量的保护

**继承：**

子类用父类的方法

**多态：**

父类有成员函数

子类有同名成员函数

如果使用子类初始化对象调用子类函数没有问题

但是使用父类创建对象，传入子类的对象的指针，父类调用函数，此时调用的是父类函数

除非，父类函数有virtual修饰

https://www.runoob.com/cplusplus/cpp-polymorphism.html

要点

虚函数和父类对象可以存储子类对象指针



1. 只有类的成员函数才能声明为虚函数，虚函数仅适用于有继承关系的类对象。普通函数不能声明为虚函数。
2. [静态成员函数](https://www.zhihu.com/search?q=静态成员函数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A37340242})不能是虚函数，因为静态成员函数不受限于某个对象。
3. [内联函数](https://www.zhihu.com/search?q=内联函数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A37340242})（inline）不能是虚函数，因为内联函数不能在运行中动态确定位置。
4. 构造函数不能是虚函数。
5. [析构函数](https://www.zhihu.com/search?q=析构函数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A37340242})可以是虚函数，而且建议声明为虚函数。



### override，OverLoad 和Final

https://blog.csdn.net/u013777351/article/details/48316177

overload 重载，函数名相同，传参类型不同

override 重写，确保自己正在尝试重写父类虚函数（避免变成了重载（写新的））

final 最终，确保自己的类或者方法不能被重写（但是可以重载）

重写隐藏

```c++
// 重写隐藏示例       
#include <iostream>
#include <cstring>

using namespace std;

class A
{
public:
    void hello(){cout<<"A hello"<<endl;}
    void hello(int i){cout<<"A hello int"<<endl;}
};

class B:public A
{
public:
    // B中的hello()隐藏了A中的hello(int)
    void hello() const{cout<<"B hello"<<endl;} 
};

// const导致重载时的隐藏问题,解决办法，在B中重新定义hello(int)函数
int main()
{
    B b;
    b.hello();
    // b.hello(1); // error
    b.A::hello(1);  // 这种情况得通过类名::的形式访问

    A *p = new B;
    // 通过父类指针类型来访问还是正确，这种情况不用类名::的形式访问
    p->hello(2); 

} 
```

子类中重写了父类的方法一部分，但是有一部分没有重写（hello(int i))

此时父类的该方法视为隐藏





### 位运算

https://www.runoob.com/w3cnote/bit-operation.html

题目和题解：

https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/solution/mian-shi-ti-15-er-jin-zhi-zhong-1de-ge-shu-wei-yun/



7.左移运算符（<<）

定义：将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。

设 a=1010 1110，a = a<< 2 将a的二进制位左移2位、右补0，即得a=1011 1000。

若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。

8.右移运算符（>>）

定义：将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。

例如：a=a>>2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。

操作数每右移一位，相当于该数除以2。





### DMA的开始传输数据线

即收到外部中断开始dma传输

将其用作外部中断使用



### 中断服务函数要做很多事情，在一个中断里面呆得时间很长，会有什么不好的后
果（低优先级中断漏响应，需要实时性的逻辑会发生错误）
那怎么解决这个问题呢 （在中断里搞个标志位，主函数获取到标志位的时
候，跳入处理函数处理原先在中断服务函数中需要做的事）

### 进程间通信的方式：

进程间通信主要包括**管道、系统IPC（包括**[**消息队列**](https://cloud.tencent.com/product/cmq?from=10680)**、信号量、信号、共享内存等）、以及套接字socket**。

![这里写图片描述](https://img-blog.csdn.net/20180712214243813?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZXJyeWRyZWFtc292ZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### STL容器和set, multiset, map, multimap区别

![](https://raw.githubusercontents.com/xutongxin1/PictureBed/master/img0/2020021320164399.png)

![](https://raw.githubusercontents.com/xutongxin1/PictureBed/master/img0/20200213201713882.png)



set 和 map区别：键值相等与否，按照元素还是键升序排列（set感觉其实都没有键这个概念）

是否带Multi的区别：是否允许键唯一（对set就是值是否允许重复）

![image-20211211160112359](https://raw.githubusercontents.com/xutongxin1/PictureBed/master/img0/image-20211211160112359.png)







# 2021-12-23 cvte初面试

有点太紧张了

题目

自我介绍

我看你做了几个项目，哪个你影响最深刻

然后问几个和你这个项目相关的问题，重点在通讯

用过GPIO吗，有哪几个模式

你说你用过I2C，速率是多少

理论上一条总线可以挂载几个设备（答案是无限！！！）

但是受分布电容影响，8个就比较多了

list和数组有什么区别

你觉得删除元素哪个快（不一定，如果是最后一个数组快）

你学过什么算法，简单描述一下

算法题（我是sb用了打表，根本不用的，而且紧张写了几个bug，按了好几次“保存”）

网站使用https://www.dooccn.com/c/

![image-20211223113931244](https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/image-20211223113931244.png)

（应该已经是最优算法了）

```c++
#include <stdio.h>

int sum1=0;//sum加法
int main(void) { 
	for(int i=6;i<1000;i++)
	{
	    for(int j=1;j<=i/2;j++)
	    {
	        if(i%j==0)
	        {
	           sum1+=j;
	        }
	    }
	    if(sum1==i)printf("%d\n",i);
	    sum1=0;
	}
	return 0;
}
```

你知道在哪里实习吗

实习后有什么打算

你还有什么问题吗？







## 2021.12.29技术二面

1、项目

2、C++和C语言的区别和优劣点

3、怎么理解面向对象

4、二叉树和红黑树讲一下

5、如何平衡技术和学校课程

6、通过什么途径去学习

7、对未来的规划

8、平时除了学习会看一些课外的书嘛



**自我介绍要简短而且不能照念**

**最大的问题是要学会引导面试官，当问你会不会什么，应该答学到哪里，而不是会不会**
