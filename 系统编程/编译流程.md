## GCC原理

-  四步骤![image-20220729000238055](https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/image-20220729000238055.png)
  - -o是拿来重命名的
  - 注意大小写，比如-s与-S
  - 上面的参数都是连带执行的，比如-c的时候，其实会完成预处理和编译的过程
  - 编译阶段出现错误会显示行号，连接阶段出错显示地址
  - ld调用collect完成连接工作
  - 当函数没有定义，也没有声明，编译器会完成隐式声明
- 日常参数（参数后的空格可以省略）
  - -I ——大i，指定头文件所在目录（如果不在同一目录下）
  - -c——只做汇编，编译和预处理（做到汇编），得到二进制文件
  - -g——编译时增加调试句柄（否则不可调试） 
  - -O2——氧气（）优化（记得默认是2级）
  - -Wall——Warning all 显示所有警告信息
  - -D Hello——定义一个Hello的宏（用于条件编译）

## 库

- 静态库
  - 以lib开头，.a结尾的文件
  - ar rcs libxxxx.a xxx.o(多个.o文件) ——生成叫libxxx.a的静态库
  - 编译时使用静态库：gcc xxx.c libxxx.a 把静态库一起编译，否则编译会无法链接
    - 源码.c在前，.a库在后
  - 静态库应该配套一个.h文件用于防止编译器在编译过程中报错或warning
- 动态库（共享库）
  - 动态库只有在程序运行到那一行才会加载进内存里，而不是一运行就加载
  - 动态库制作
    - gcc -c add.c -o add.o -fPIC
      - 生成与位置无关的代码-fPIC用于动态库制作
      - 汇编里面生成的代码就会带@pic

    - gcc -shared libxxxx.so xxx.o(多个.o文件)
      - 此处.o的文件编译时要加参数-fPIC，不加的不行
  - 动态库使用
    - gcc test.c -o a.out -lxxxx -L./lib
      - -l指定库名
      - -L指定库路径
      - 不需要空格
    - 运行a.out时找不到动态库
      - 链接器与动态链接器
        - 链接器用于程序链接阶段，使用-l与-L参数
        - 动态链接器用于程序运行阶段，工作时需要提供动态库所在目录
          - 通过提供LD_LIBRARY_PATH=动态库路径 的环境变量
            - 实际指令需要加export使其生效——export LD_LIBRARY_PATH=./lib
            - 环境变量仅跟随该终端，新的终端就没这个环境变量了
              - 可以修改~/.bashrc实现关闭后继续有该环境变量
                - 记得使用.bashrc运行以重载环境变量，或者使用source .bashrc
                - 记得可能需要使用绝对路径保证其他路径下也可以加载
        - 把自己的动态库放入/lib中（默认加载的地址）
        - 修改动态链接库的配置文件
          - /etc/ld.so.conf ，向其中写入动态库的绝对路径
            - 不用加include
          - 使用sudo ldconfig使配置文件生效
    - ldd a.out——查看该程序所需要依赖的动态库的路径
      - 如果没有找到就是空
- 区别：
  - 静态库在链接阶段本质上会复制进.out文件中打包进去
  - 动态库在链接时不复制进去，在运行时把动态库放到内存里运行，多个应用程序可以只加载一次，因此也叫共享库
  - 但是理论上由于不需要去内存里找，所以静态库更快
  - ![image-20220729002726961](https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/image-20220729002726961.png)

![image-20220804203103057](https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/image-20220804203103057.png)

随着函数调用，会在stack上开辟一片内存控制，用于存放函数调用时产生的局部变量和临时值

## GDB

- 首先记得gcc -g xxx.c,使用-g使生成的程序可以调试
- 使用gdb a.out
  - l ==  list 查看当前被调试的代码
    - l 1显示第一行
    - 继续使用l即继续向下翻
  - b == break 打断点
    - b 52 在52行打断点
  - r == run 运行程序
  - n == next 步进
  - s ==step 步入
    - 对于系统函数不能步入，否则要用until或者finish
  - p == print 打印变量的值
  - continue 继续执行程序
  - quit 退出GDB
- 其他指令与功能
  - 检查段错误的位置，直接run就会停在段错误的位置（内存转储）
  - until 20 运行直到20行
  - finish 结束当前函数调用，到下一行
  - start 运行main函数第一行
  - set args xxx 输入给scanf等
  - run xxx 输入给scanf等
  - info b 查看现在的断点信息
  - b 20 if i=5 设置条件断点
  - ptype i 查看i变量的类型
  - bt 查询函数调用栈（看从哪里调用进来的），列出栈帧
    - frame 1 切换栈帧，查看其他栈帧的变量情况
    - ![image-20220806124337975](https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/image-20220806124337975.png)
  - display i 持续显示变量的值
    - undisplay 1 取消显示变量，使用的是display的编号值
  - file a.out 读取一个新的程序准备调试
- 常见问题
  - 没有符号表被读取——没有使用-g编译

## makefile

- 文件命名只能使用makefile或者Makefile，否则不能直接使用make

- 一个规则

  - ```
    目标:依赖条件
    （一个tab）命令
    如：
    
    hello:helllo.c
    	gcc hello.c -o hello
    ```

  - ```
    依赖可以是文件，也可以是另一个指令
    hello:hello.o
    	gcc hello.o -o hello
    hello.o:hello.c
    	gcc -c hello.c -o hello.o
    make启动后找不到hello.o文件，但是找到依赖指令，进而先执行hello.o的生成
    ```
  
  - ```
    ALL:xxx.out
     否则默认执行第一个生成后结束
    ```

- 两个函数

  - ```
    wildcard（通配符）
    src=$(wildcard ./*.c)
    匹配当前工作目录下所有的.c文件，将文件名组成列表复制给src
    src=xxx.c xxx.c xxx.c
    ```

  - ```
    patsubst
    obj=$(patsubst %c,%o,$(src))
    将参数3中，包含参数1的部分，替换为参数2，组成列表赋值给obj
    obj=xxx.o xxx.o xxx.o
    ```

  - ![image-20220901222905084](https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/image-20220901222905084.png)

    - clean不需要依赖
    - -rm，前面加个-是指错误忽略继续执行

- 三个自动变量

  - $@ 在规则的命令（不能是目标和依赖）中表示目标
  - $^ 在规则的命令中表示所有依赖条件
  - $< 在规则的命令中表示第一个依赖条件
  -  ![image-20220902140750433](https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/image-20220902140750433.png)

- 模式规则

  - ```
    %.o:%.c
    	gcc -c $< -o %@
    ```

  - 此时$<可将依赖条件列表中的依赖依次取出，套用模式规则

  - ![image-20220902141741175](https://raw.githubusercontents.com/xutongxin1/PictureBed/master/img0/image-20220902141741175.png)

  - 静态模式规则

    - ```
      $(obj):%.o:%.c
      	gcc -c $< -o %@
      ```

    - 只有缺少依赖obj时才匹配该静态模式规则，指定模式规则给谁用

    - ![image-20220902142113836](https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/image-20220902142113836.png)

- 伪目标.PHONY

  - ![image-20220902142338475](https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/image-20220902142338475.png)

- 自定义变量，如编译附加指令myArgs
  - ![image-20220902142548259](https://raw.githubusercontent.com/xutongxin1/PictureBed/master/img0/image-20220902142548259.png)

